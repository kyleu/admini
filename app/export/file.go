package export

import (
	"fmt"
	"sort"
	"strings"

	"github.com/kyleu/admini/app/util"
)

type line struct {
	Indent  int
	Content string
}

type File struct {
	Pkg        util.Pkg
	Filename   string
	Imports    []string
	Type       FileType
	currIndent int
	output     []line
}

func NewJSONFile(pkg util.Pkg, key string) *File {
	if !strings.HasSuffix(key, ".json") {
		key += ".json"
	}
	return &File{Pkg: pkg, Filename: key, Type: FileTypeJSON}
}

func NewGoFile(pkg util.Pkg, key string) *File {
	if !strings.HasSuffix(key, ".go") {
		key += ".go"
	}
	return &File{Pkg: pkg, Filename: key, Type: FileTypeGo}
}

func (f *File) W(content string, indentDelta ...int) {
	for _, x := range indentDelta {
		if x < 0 {
			f.currIndent += x
		}
	}
	f.output = append(f.output, line{Indent: f.currIndent, Content: content})
	for _, x := range indentDelta {
		if x > 0 {
			f.currIndent += x
		}
	}
}

func (f *File) LB() {
	f.W("")
}

func (f *File) Wf(content string, args ...interface{}) {
	f.W(fmt.Sprintf(content, args...))
}

func (f *File) AddImport(imp string) {
	for _, i := range f.Imports {
		if i == imp {
			return
		}
	}
	f.Imports = append(f.Imports, imp)
}

func (f *File) AddComment(content string) {
	l := f.comment(content)
	f.W(l.Content, l.Indent)
}

func (f *File) comment(content string) line {
	prefix := "# "
	if f.Type == FileTypeGo {
		prefix = "// "
	}
	return line{Content: prefix + content}
}

func (f *File) MarshalJSON() ([]byte, error) {
	return util.ToJSONBytes(map[string]interface{}{
		"path":  strings.Join(append(f.Pkg, f.Filename), "/"),
		"lines": f.Render(),
	}, false), nil
}

func (f *File) Render() []string {
	indent := "  "
	header := []line{}
	if f.Type != FileTypeJSON {
		header = append(header, f.comment(fmt.Sprintf("generated by %s", util.AppName)))
	}
	var footer []line
	if f.Type == FileTypeGo {
		if len(f.Pkg) == 0 {
			header = append(header, line{Content: "package " + util.AppName})
		} else {
			header = append(header, line{Content: "package " + f.Pkg[len(f.Pkg)-1]})
		}
		header = append(header, line{})
		indent = "\t"
	}
	lines := append([]line{}, header...)
	lines = append(lines, goImportsFor(f.Imports)...)
	lines = append(lines, append(f.output, footer...)...)

	ret := make([]string, 0, len(lines))
	for _, l := range lines {
		indention := ""
		for i := 0; i < l.Indent; i++ {
			indention += indent
		}
		ret = append(ret, indention+l.Content)
	}
	return ret
}

func goImportsFor(imps []string) []line {
	if len(imps) == 0 {
		return nil
	}
	sort.Strings(imps) // TODO improve
	ret := make([]line, 0, len(imps)+1)
	for _, i := range imps {
		ret = append(ret, line{Content: "\"" + i + "\""})
	}
	ret = append(ret, line{})
	return ret
}

func (f *File) RenderString() string {
	return strings.Join(f.Render(), "\n")
}

func (f *File) Path() string {
	return f.Pkg.ToPath(f.Filename)
}
